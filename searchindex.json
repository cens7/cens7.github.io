{"categories":[],"posts":[{"content":"常用命令    命令 描述     docker login 登陆   docker logout 登出   docker search [xxx] 搜索镜像   docker pull [xxx] 拉取指定名字的镜像   docker rm [container_id] 根据容器id删除   docker rmi [image_id] 根据镜像id删除   docker ps 查看所有正在运行的容器   docker container ps 查看所有正在运行的容器   docker container ps -a 查看所有容器   docker images 查看所有镜像   docker image ls 查看所有镜像   docker image ls -f dangling=true 查看虚悬镜像(官方发了新版)   dcker system df 查看doker镜像磁盘占用率   docker container rm [container_id] 根据容器id删除容器   docker image rm [image_id] 根据镜像id删除镜像   docker stop [container_id / container_name] 停止指定id的容器   docker start [container_id / container_name] 运行指定id的容器   docker volume create xxx 创建一个数据卷   docker volume ls 查看所有的数据卷   docker volume inspect xxx 查看指定的数据卷   docker volume rm xxx 删除指定的数据卷   docker volume prune 清理无效的数据卷   docker run xxx 运行指定镜像   docker exec -it xxx /bin/bash 进入指定容器   docker network ls 查看容器所有的网络   docker network prune 清理无效的网络   docker network 查看docker网络   docker logs [container_id] 查看指定容器id的日志   docker logs -f 查看指定容器的日志条数   docker port [container_id / container_name] 查询指定容器的端口映射    ","id":0,"section":"posts","summary":"常用命令 命令 描述 docker login 登陆 docker logout 登出 docker search [xxx] 搜索镜像 docker pull [xxx] 拉取指定名字的镜像 docker rm [container_id] 根据容器id删除 docker rmi [image_id] 根据镜像id删除 docker ps 查看所有正在运行的容器","tags":["docker"],"title":"docker使用","uri":"https://cens7.github.io/2019/12/docker%E4%BD%BF%E7%94%A8/","year":"2019"},{"content":"问题 同样的dubbo应用，同事启动只要10秒不到，我启动要2分钟，遂不服。万能的stackoverflow告诉我，我需要设置hosts。\n配置对应的hosts :(1) 127.0.0.1 localhost huanghuandeMacBook-Pro.local ::1 localhost huanghuandeMacBook-Pro.local  配置完成host发现启动从2分钟优化到了6秒！但是会有错误日志！作为强迫症的我岂能忍？！错误日志内容：开始调试：\n1. 先`telent 127.0.0.1 20880`本地dubbo, ok是好的； 2. ll 看一下本地的dubbo provider接口列表； 3. 选中一个，invoke xxx.xx.xx.xxxProvider.test()，ok也是好的。  以上说明我的dubbo接口成功。\n 1. 进入本地nacos看一下dubbo是否注册上去，ok是好的。  捋一捋，dubbo接口是好的，dubbo注册成功，但是为什么启动会报错。\n把改过的hosts改回去：(2)\n 127.0.0.1 localhost ::1 localhost  改回hosts,启动虽然慢了点，但是不报错。\n使用debug大法：\n 将hosts改成 (1) 从上面错误日志那行源码点进去打断点，发现dubbo绑定的地址是127.0.0.1。 将hosts改成 (2) 再启动，dubbo绑定的地址改成了我的内网ip192.168.5.143。很明显因为我配置了主机名，造成dubbo绑定的ip从内网ip192.168.5.143变成了主机ip127.0.0.1；所以这是为什么呢。其实官方已经在这里给了解释。  按照官方给的解释:\n Dubbo选取本地地址的逻辑大致分成了两步； 先去 /etc/hosts 文件中找 hostname 对应的 IP 地址，找到则返回；找不到则转到去 轮询网卡，寻找合适的 IP 地址，找到则返回；找不到返回 null，如果返回 null，则注册 127.0.0.1 这个本地回环地址\n 所以我的问题就是没有找到合适的ip地址而去注册了127.0.0.1这个本地地址。\n于是将我的hosts改成：192.168.5.143 localhost huanghuandeMacBook-Pro.local ::1 localhost huanghuandeMacBook-Pro.local  或者：在启动应用的时候加上启动参数： -DDUBBO_IP_TO_BIND=192.168.5.143  问题解决。\n","id":1,"section":"posts","summary":"问题 同样的dubbo应用，同事启动只要10秒不到，我启动要2分钟，遂不服。万能的stackoverflow告诉我，我需要设置hosts。 配置","tags":["Java","Dubbo","架构","问题"],"title":"Dubbo启动太慢","uri":"https://cens7.github.io/2019/12/dubbo%E5%90%AF%E5%8A%A8%E5%A4%AA%E6%85%A2/","year":"2019"},{"content":"一、背景 介绍：XSS(Cross Site Scripting)指的是用户注入恶意的代码，浏览器和服务器没有对用户的输入进行过滤，导致用户注入的脚本嵌入到了页面中。由于浏览器无法识别这些恶意代码正常解析执行，攻击者的恶意操作被成功执行。\n预防XSS攻击不仅是前端开发人员要做的事情，也是是后端开发人员要做的事情。本篇章节是针对后端开发人员怎么预防XSS攻击。\n常见的XSS攻击分为三种：\n 反射型： 通过在请求地址上加上恶心的HTML代码。 dom型： 通过一些api向网站注入一些恶心的HTML代码。 持久型： 攻击者通过把代码提交到后台数据库中;当用户下次打开的时候就会从后台接收这些恶意的代码。  防范：\n 反射型： 前端通过转义来进行防范以及过滤 dom型：前端通过转义来进行防范以及过滤 持久型：服务端通过转义存储进行防范  对于反射型与dom型的XSS攻击，需要前端做转义。本篇博客主要讲解后端的转义处理。\n二、目的  针对输入包含dom敏感的数据进行过滤 针对输入包含sql相关的敏感信息进行过滤  三、实现方式 使用Filter过滤器使用Filter，将所有的敏感信息替换成空字符串  public class XSSPreventionFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { XSSRequestWrapper wrapper = new XSSRequestWrapper((HttpServletRequest) request); chain.doFilter(wrapper, response); } class XSSRequestWrapper extends HttpServletRequestWrapper { private Map\u0026lt;String, String[]\u0026gt; sanitizedQueryString; XSSRequestWrapper(HttpServletRequest request) { super(request); } @Override public String getParameter(String name) { String parameter = null; String[] vals = getParameterMap().get(name); if (vals != null \u0026amp;\u0026amp; vals.length \u0026gt; 0) { parameter = vals[0]; } return parameter; } @Override public String[] getParameterValues(String name) { return getParameterMap().get(name); } @Override public Enumeration\u0026lt;String\u0026gt; getParameterNames() { return Collections.enumeration(getParameterMap().keySet()); } @Override public Map\u0026lt;String, String[]\u0026gt; getParameterMap() { if (sanitizedQueryString == null) { Map\u0026lt;String, String[]\u0026gt; res = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, String[]\u0026gt; originalQueryString = super.getParameterMap(); if (originalQueryString != null) { for (String key : originalQueryString.keySet()) { String[] rawVals = originalQueryString.get(key); String[] snzVals = new String[rawVals.length]; for (int i = 0; i \u0026lt; rawVals.length; i++) { snzVals[i] = stripXSS(rawVals[i]); } res.put(stripXSS(key), snzVals); } } sanitizedQueryString = res; } return sanitizedQueryString; } /** * 从字符串中删除所有潜在的恶意字符 * * @param value the raw string * @return the sanitized string */ private String stripXSS(String value) { String cleanValue = null; if (value != null) { cleanValue = Normalizer.normalize(value, Normalizer.Form.NFD); // 删除空字符 cleanValue = cleanValue.replaceAll(\u0026quot;\\0\u0026quot;, \u0026quot;\u0026quot;); // 删除\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;标签 Pattern scriptPattern = Pattern.compile(\u0026quot;\u0026lt;script\u0026gt;(.*?)\u0026lt;/script\u0026gt;\u0026quot;, Pattern.CASE_INSENSITIVE); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除src='...' scriptPattern = Pattern.compile(\u0026quot;src[\\r\\n]*=[\\r\\n]*'(.*?)'\u0026quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除\u0026lt;/script\u0026gt;标签 scriptPattern = Pattern.compile(\u0026quot;\u0026lt;/script\u0026gt;\u0026quot;, Pattern.CASE_INSENSITIVE); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除\u0026lt;script ...\u0026gt;标签 scriptPattern = Pattern.compile(\u0026quot;\u0026lt;script(.*?)\u0026gt;\u0026quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除eval(...)表达式 scriptPattern = Pattern.compile(\u0026quot;eval\\\\((.*?)\\\\)\u0026quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除expression(...)表达式 scriptPattern = Pattern.compile(\u0026quot;expression\\\\((.*?)\\\\)\u0026quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除javascript:...表达式 scriptPattern = Pattern.compile(\u0026quot;javascript:\u0026quot;, Pattern.CASE_INSENSITIVE); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除vbscript:...表达式 scriptPattern = Pattern.compile(\u0026quot;vbscript:\u0026quot;, Pattern.CASE_INSENSITIVE); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除onload= 表达式 scriptPattern = Pattern.compile(\u0026quot;onload(.*?)=\u0026quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除 sql ' 和 ; 字符串 scriptPattern = Pattern.compile(\u0026quot;[';]\u0026quot;, Pattern.CASE_INSENSITIVE); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); // 删除 sql -- 字符 scriptPattern = Pattern.compile(\u0026quot;--\u0026quot;, Pattern.CASE_INSENSITIVE); cleanValue = scriptPattern.matcher(cleanValue).replaceAll(\u0026quot;\u0026quot;); } return cleanValue; } } }  配置Filter过滤器\n配置xss防注入filter bean  @Configuration public class FilterConfig { @Bean public FilterRegistrationBean filterRegistrationBean() { FilterRegistrationBean frb = new FilterRegistrationBean(); frb.setFilter(new XSSPreventionFilter()); frb.setOrder(1); frb.addUrlPatterns(\u0026quot;/*\u0026quot;); return frb; } }  以上完成，搞定。\n","id":2,"section":"posts","summary":"一、背景 介绍：XSS(Cross Site Scripting)指的是用户注入恶意的代码，浏览器和服务器没有对用户的输入进行过滤，导致用户注入的脚本嵌","tags":["Java","安全","xss"],"title":"防xss攻击","uri":"https://cens7.github.io/2019/11/%E9%98%B2xss%E6%94%BB%E5%87%BB/","year":"2019"},{"content":"使用redisson 1.pom依赖  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.redisson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redisson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   2.配置对应redisson @Configuration public class RedissonConfig { @Autowired(required = false) RedissonProperties redissonProperties; @Bean(destroyMethod = \u0026quot;shutdown\u0026quot;) @ConditionalOnMissingBean(RedissonClient.class) public RedissonClient redissonClient() { if (Objects.nonNull(redissonProperties)) { Config config = new Config(); String[] nodes = redissonProperties.getSentinelNodes().split(\u0026quot;,\u0026quot;); SentinelServersConfig sentinelServersConfig = config.useSentinelServers() .setMasterName(redissonProperties.getMasterName()) .setDatabase(redissonProperties.getDatabase()) .setConnectTimeout(redissonProperties.getConnectTimeout()) .setPassword(redissonProperties.getPassword()); for (String node : nodes) { sentinelServersConfig = sentinelServersConfig.addSentinelAddress(\u0026quot;redis://\u0026quot; + node); } return Redisson.create(config); } else { return null; } } }  3.使用 这里是官方文档\n1) 使用普通锁(可重入锁) 注意：可重入锁lock()几次，就要对应的unlock()几次\n2) 使用公平锁 公平锁秉持先到先得原则，先请求获取锁的线程先获取到锁，后来的线程等待。\n@Autowired private RedissonClient redisson; public void demo() { RLock lock = redisson.getLock(\u0026quot;lock\u0026quot;); lock.lock(2, TimeUnit.SECONDS); Thread t = new Thread(() -\u0026gt; { RLock lock1 = redisson.getLock(\u0026quot;lock\u0026quot;); lock1.lock(); lock1.unlock(); }); t.start(); t.join(); lock.unlock(); }  3) 使用读写锁 4) 使用红锁 使用redlock需要多个redissonClient，多个redissonClient需要多个互相独立的哨兵，我们的项目里目前只有一个哨兵，所以暂不推荐使用红锁\n上面是4种比较常用的分布式锁机制，我们针对不同业务作出不同选型。\n redisson将各种锁的概念与java的各种锁完美的结合在一起，封装做的非常巧妙，甚至对于CountDownLatch、Semaphore、Atomic等等也有很多精妙绝伦的封装，感兴趣的同学可以研究一下官方文档。\n 注意：1. 不管使用哪一种锁，都需要设置锁的过期时间。 2. 使用lock()、tryLock()时，一定要放在try{}catch(){}中，且unlock一定要放在finally{}里 3. 所有需要使用分布式锁场景的锁名，都要使用枚举、常量统一管理  redisson锁原理 1) tryLock()表示尝试加锁，加锁成功返回true，加锁失败返回false。使用tryLock()加锁，线程没有获取到锁不会阻塞。 使用tryLock()加锁流程： 2) lock() 加锁，此锁已被持有则等待，没有被持有则获取这把锁。使用lock()加锁，线程没有获取到锁会一直阻塞直到获取到锁。 使用lock()加锁流程： 3) 使用可重入锁、公平锁、读写锁时，执行的lua脚本各不相同。    类型 加锁lua 解锁lua     可重入锁 红锁     公平锁     读锁     写锁      4）tryLock()与lock()的使用场景  场景一： 库存抢占。有效库存只有100，多个应用来抢占这100个库存总数。这时使用：lock() 场景二： 退款申请。网络卡顿或其他原因同时段提交多次退款申请，实际只生成一条退款单。这时使用：tryLock()  5）tryLock()与lcok()使用的注意事项  tryLock() 尝试获取锁,不等待，返回获取结果。 tryLock(long waitTime, TimeUnit timeUnit) 尝试获取锁，并等待waitTime个时间单位，之后返回获取结果。 tryLock(long waitTime, long leaseTime, TimeUnit timeUnit) 尝试获取锁，并等待waitTIme个时间单位，并将此锁持有leaseTime个时间单位，之后返回获取结果。 lock() 获取锁，线程阻塞，直到获取到锁为止，锁不过期，直到解锁或者被内部机制释放。 lock(long leaseTime, TimeUnit timeUnit) 获取锁，直到获取到锁为止，持有锁leaseTime个时间单位，之后自动释放锁，也可以提前手动释放。  6）公平锁、可重入锁、读写锁、红锁的使用场景   场景一： 门票只有100张。先到先得。这时使用公平锁  场景二： 1. 门票只有100张，需要抢票。2. 需要把下一张门票修改成vip票。 (可重入锁是在一个线程中多次获取同一把锁。一个线程在执行一个带锁的方法时，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁)  场景三： 所有人都能看到库存信息，但同时只有一个人来修改库存。所有的人都能看到库存信息，使用读锁。同时只有一个人来修改库存，使用写锁。多个读锁不互斥，读锁与写锁互斥  场景四： 当需要超级高可用锁的场景时，使用红锁。\n综上所述，使用tryLock还是lock，使用公平锁还是读写锁都是看具体的业务和场景而言。\n  ","id":3,"section":"posts","summary":"使用redisson 1.pom依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.redisson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redisson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.配置对应redisson @Configuration public class RedissonConfig { @Autowired(required = false) RedissonProperties redissonProperties; @Bean(destroyMethod = \u0026quot;shutdown\u0026quot;) @ConditionalOnMissingBean(RedissonClient.class) public RedissonClient redissonClient() { if (Objects.nonNull(redissonProperties)) { Config config = new Config(); String[] nodes = redissonProperties.getSentinelNodes().split(\u0026quot;,\u0026quot;); SentinelServersConfig sentinelServersConfig = config.useSentinelServers()","tags":["Java","redis"],"title":"使用redisson做分布式锁","uri":"https://cens7.github.io/2019/11/%E4%BD%BF%E7%94%A8redisson%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","year":"2019"},{"content":" 从数据库工具（比如：navicat）中导出表结构sql。 将sql导入到powerDesigner里。  File → Reverse Engineer → Database选中导出的表结构sql点确定，生成pdm   将comment的值写到name上Tools → Execute Commonds → Edit/Run Script    写入代码点run，然后close弹窗：   把code驼峰转为下划线  搞定\n","id":4,"section":"posts","summary":"从数据库工具（比如：navicat）中导出表结构sql。 将sql导入到powerDesigner里。 File → Reverse Engineer → Database选中导出的表结","tags":["工具"],"title":"PowerDesigner行列转换脚本","uri":"https://cens7.github.io/2019/08/powerdesigner%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2%E8%84%9A%E6%9C%AC/","year":"2019"},{"content":"问题 pringCloud整合的rabbitmq， 在消费端设置了group，通常情况消费端只消费了一次，偶尔碰到一次 mq被消费两次。  解决 添加groupId 分组  ","id":5,"section":"posts","summary":"问题 pringCloud整合的rabbitmq， 在消费端设置了group，通常情况消费端只消费了一次，偶尔碰到一次 mq被消费两次。 解决 添加g","tags":["Java","SpringCloud","问题"],"title":"SpringCloud中rabbitmq被消费多次","uri":"https://cens7.github.io/2018/06/springcloud%E4%B8%ADrabbitmq%E8%A2%AB%E6%B6%88%E8%B4%B9%E5%A4%9A%E6%AC%A1/","year":"2018"},{"content":"lambda基本使用 1.将List转成Map\u0026lt;Id,Person\u0026gt;  Map\u0026lt;Id,Person\u0026gt; map = list.parallelStream(). collect(Collectors.toMap(Person::getId, p -\u0026gt; p));\n 2.将List按照sex分组  Map\u0026lt;String,Person\u0026gt; map = list.parallelStream(). collect(Collectors.groupingBy(Person::getSex));\n 3.取出List的平均score  dobble avg = list.parallelStream(). mapToDouble(p -\u0026gt; p.getScore()).average().getAsDouble();\n 4.取出List中id为10的学生  Optionalop = list.parallelStream().filter(p -\u0026gt; p.getId().equals(10)).findFirst(); Person p = op.get();\n 5.取出List中所有的id  Listids = list.parallelSream().map(Person::getId).collect(Collectors.toList());\n 6.根据score,取前100名 （降序）  Listpersons =list.parallelStream(). sorted(Comparator.comparing(Person::getScore()).reversed()). limit(100).collect(Collectors.toList());//使用guava ListpeopleList1 = Ordering.natural().onResultOf(People::getId).sortedCopy(peopleList);\n 7.取出分数最高的学生信息  Person person = list.parallelStream().max(Comparator.comparing(Person::getScore()).get();\n// 只能取出最小的ID 不能取出整个对象\nInteger min = Ordering.natural().reverse().min(Iterables.transform(peopleList, People::getId));\n 8.算所有学生的分数  Long sum = list.parallelStream().map(Person::getScore).reduce((x1,x2) -\u0026gt; x1+x2).get();\n 9.求所有金钱总和  BigDecimal money = list.parallelStream().map(Person::getMoney).reduce(BigDecimal::add).get();\n 10.取出两个不同List对象中相等的Id   11.剔除List中金钱一样的对象   Collectionvalues = list.parallelStream(). collect(Collectors.toMap(Person::getMoney, p -\u0026gt; p , (p,q) -\u0026gt; p)).values();       12.将List转成Map\u0026lt;Long,List\u0026gt;。 (如果需要，可以转成Map\u0026lt;String,List\u0026gt;等等)\n Map\u0026lt;Long, List\u0026gt; result = listHello.stream().collect(Collectors.groupingBy(Person::getId));\n 13.CompletableFuture结合lambda异步执行并汇总   14.对象转map  Map\u0026lt;String, String\u0026gt; collect = privilegeObjList.stream().collect(Collectors.toMap(PlatformPrivilegeF::getModuleNo, PlatformPrivilegeF::getPrivilege));\n 15.把对象的moduleNo当Map的key，privilege当map的value List集合元素。  Map\u0026lt;String, List\u0026gt; map = privilegeObjList.stream().collect( Collectors.groupingBy(PlatformPrivilegeF::getModuleNo, Collectors.mapping(PlatformPrivilegeF::getPrivilege, Collectors.toList())));\n ","id":6,"section":"posts","summary":"lambda基本使用 1.将List转成Map\u0026lt;Id,Person\u0026gt; Map\u0026lt;Id,Person\u0026gt; map = list.parallelStream(). collect(Collectors.toMap(Person::getId, p -\u0026gt; p)); 2.将List按照sex分组 Map\u0026lt;String,Person\u0026gt; map = list.parallelStream(). collect(Collectors.groupingBy(Person::getSex)); 3.取出","tags":["Java","lambda"],"title":"Lambda基本使用","uri":"https://cens7.github.io/2017/04/lambda%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","year":"2017"},{"content":"基本设置 关闭默认打开工程：关闭大小写敏感：换行显示10个文件选项卡：常用插件  lombok 注解 mybatis plugin maven helper String Manipulation 字符串处理 Translation 翻译  ","id":7,"section":"posts","summary":"基本设置 关闭默认打开工程：关闭大小写敏感：换行显示10个文件选项卡：常用插件 lombok 注解 mybatis plugin maven helper String Manipulation 字符串处理 Translation 翻译","tags":["idea"],"title":"idea基本设置","uri":"https://cens7.github.io/2016/12/idea%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/","year":"2016"},{"content":"位逻辑运算符 与运算（\u0026amp;） 与运算：两个运算数比较位都是 1，则结果为 1，否则为 0。例如：5 \u0026amp; 3 = 1\n0000 0000 0000 0000 0000 0000 0000 0101 5 转换为二进制 0000 0000 0000 0000 0000 0000 0000 0011 3 转换为二进制 0000 0000 0000 0000 0000 0000 0000 0001 换算成 10 进制为 1  或运算（|） 或运算：两个运算数比较位有一个为 1，则结果为 1，否则为 0。例如：5 | 3 = 7\n0000 0000 0000 0000 0000 0000 0000 0101 5 转换为二进制 0000 0000 0000 0000 0000 0000 0000 0011 3 转换为二进制 0000 0000 0000 0000 0000 0000 0000 0111 换算成 10 进制为 7  异或运算（^） 异或运算：两个运算数比较位不同时，其结果是 1，否则为 0。例如：5 ^ 3 = 6\n0000 0000 0000 0000 0000 0000 0000 0101 5 转换为二进制 0000 0000 0000 0000 0000 0000 0000 0011 3 转换为二进制 0000 0000 0000 0000 0000 0000 0000 0110 换算成 10 进制为 6  非运算（~） 非运算：也叫做补，一元运算符，对其运算数的每一位取反。例如：~5 = -6\n0000 0000 0000 0000 0000 0000 0000 0101 5 转换为二进制 1111 1111 1111 1111 1111 1111 1111 1010 取非后的原码 1000 0000 0000 0000 0000 0000 0000 0110 转换补码，换算成 10 进制为 -6  ####其它\n  Java 中整数类型（byte、short、int 和 long）在内存中是以有符号的二进制补码表示。所以位运算时，首先要转换为原码。\n  补码转原码：补码转原码和原码转补码的方法是一样的，取反 + 1（补码的补码是原码）。\n  当位运算数是 byte 和 short 类型时，将自动把这些类型扩大为 int 型（32 位）。\n  计算出 n 位二进制数所能表示的最大十进制数位移算法：-1L ^ (-1L \u0026laquo; n) 或 ~(-1L \u0026laquo; n)。\n  byte 和 int 相互转换\n  int i = 234; byte b = (byte) i; // 结果：b = -22 // 转换过程： // 0000 0000 0000 0000 0000 0000 1110 1010 # int 234 的补码（与原码相等） // 1110 1010 # byte 低位截取 // 1001 0110 # 求得补码，转为 10 进制为 -22 int x = b ; // 结果为：x = -22；8 位 byte 的转 32 的 int，值不变。 int y = b \u0026amp; 0xff; // 结果为：x = 234； 可以通过将其和 0xff 进行位与（\u0026amp;）得到它的无符值 // 转换过程： // 1001 0110 # byte -22 的原码 // 1000 0000 0000 0000 0000 0000 0001 0110 # int -22 的原码 // 1111 1111 1111 1111 1111 1111 1110 1010 # int -22 补码 // 0000 0000 0000 0000 0000 0000 1111 1111 # 0xff 的二进制数 // 0000 0000 0000 0000 0000 0000 1110 1010 # 和 0xff 进与操作的结果，转换为 10 进制为 234  ","id":8,"section":"posts","summary":"位逻辑运算符 与运算（\u0026amp;） 与运算：两个运算数比较位都是 1，则结果为 1，否则为 0。例如：5 \u0026amp; 3 = 1 0000 0000 0000 0000 0000 0000 0000 0101 5 转换为二进制 0000 0000 0000 0000","tags":["数据结构"],"title":"Java位运算2_位运算","uri":"https://cens7.github.io/2016/02/java%E4%BD%8D%E8%BF%90%E7%AE%972_%E4%BD%8D%E8%BF%90%E7%AE%97/","year":"2016"},{"content":"左移运算（\u0026laquo;） value \u0026lt;\u0026lt; num   num 指定要移位值；value 移动的位数。\n 将左操作数（value）转为二进制数后向左边移动 num 位，并且在低位补 0，高位丢弃。\n例如：5 \u0026laquo; 2\n0000 0000 0000 0000 0000 0000 0000 0101 5 的补码（同原码） 0000 0000 0000 0000 0000 0000 0001 0100 左移 2 位后，低位补 0。换算成 10 进制为 20  如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如：对 int 类型（最大位数 32）的数值移动 33 位，实际上只移动了 33 % 32 = 1 位。\n 注：n 位二进制，最高位为符号位，因此表示的数值范围：−2(𝑛−1) —— 2(𝑛−1)−1，所以模为：2(𝑛−1)。\n 在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以 2 的 1 次方，左移 n 位就相当于乘以 2 的 n 次方。如：5 \u0026laquo; 2 相当于 5∗22=20。\n如果移进高阶位（int 31 或 long 63 位），那么该值将变为负值。如：1 \u0026laquo; 31 = -2147483648\n右移运算（\u0026raquo;） value \u0026gt;\u0026gt; num   num 指定要移位值；value 移动的位数。\n 将左操作数（value）转为二进制数后向右边移动 num 位，符号位不变，高位补上符号位（若左操作数是正数，则高位补 0，若左操作数是负数，则高位补 1），低位丢弃。\n右移时，被移走的最高位（最左边的位）由原来最高位的数字补充，这叫做符号位扩展（保留符号位）（sign extension），在进行右移操作时用来保持负数的符号。\n例如：7 \u0026raquo; 2\n0000 0000 0000 0000 0000 0000 0000 0111 7 的补码（同原码） 0000 0000 0000 0000 0000 0000 0000 0001 右移 2 位后，高位补 0。换算成 10 进制为 1  例如：-7 \u0026raquo; 2\n1000 0000 0000 0000 0000 0000 0000 0111 -7 的原码 1111 1111 1111 1111 1111 1111 1111 1000 -7 的反码 1111 1111 1111 1111 1111 1111 1111 1001 -7 的补码 1111 1111 1111 1111 1111 1111 1111 1110 右移 2 位后，高位补 1 1000 0000 0000 0000 0000 0000 0000 0010 补码转原码。换算成 10 进制为 -2  正数右移 n 位相当于除以 2 的 n 次方并且舍弃了余数。如：7 \u0026raquo; 2 相当于： 7/22=1。\n负数右移 n 位相当于除以 2 的 n 次方，如果有余数 -1。如：-7 \u0026raquo; 2 相当于： 7∗22−1=−2。\n例子：\npublic static void main(String[] args) { // 左移 int i = 16; // 在二进制i的右边加两个零，也就是二进制乘以100 // 100换算成10进制，乘以4 // 也可能看作是乘以2的2次幂 int i1 = i \u0026lt;\u0026lt; 2; int i2 = i * (2 * 2); System.out.println(\u0026quot;i1 = \u0026quot; + i1 + \u0026quot;, i2 = \u0026quot; + i2); // 在二进制i的右边加三个零，也就是二进制乘以1000 // 1000换算成10进制，乘以8 // 也可能看作是乘以2的3次幂 int i3 = i \u0026lt;\u0026lt; 3; int i4 = i * (2 * 2 * 2); System.out.println(\u0026quot;i3 = \u0026quot; + i3 + \u0026quot;, i4 = \u0026quot; + i4); // -------------------------------------------------------- // 右移 int j = 16; // 在二进制i的右边减少两个零，也就是二进制除以100 // 100换算成10进制，除以4 // 也可能看作是除以2的2次幂 int j1 = j \u0026gt;\u0026gt; 2; int j2 = i / (2 * 2); System.out.println(\u0026quot;j1 = \u0026quot; + j1 + \u0026quot;, j2 = \u0026quot; + j2); }  无符号右移（\u0026raquo;\u0026gt;） value \u0026gt;\u0026gt;\u0026gt; num   num 指定要移位值；value 移动的位数。\n 将左操作数（value）转为二进制数后向右边移动 num 位，0 补最高位（忽略了符号位扩展）。\n无符号右移运算只是对 32 位和 64 位的值有意义。\n例如：-7 \u0026raquo;\u0026gt; 2\n1000 0000 0000 0000 0000 0000 0000 0111 -7 的原码 1111 1111 1111 1111 1111 1111 1111 1001 -7 的补码 0011 1111 1111 1111 1111 1111 1111 1110 右移 2 位后，高位补 0。换算成 10 进制为 1073741822  ","id":9,"section":"posts","summary":"左移运算（\u0026laquo;） value \u0026lt;\u0026lt; num num 指定要移位值；value 移动的位数。 将左操作数（value）转为二进制数后向左边移动 num 位，并且在低位补 0，","tags":["数据结构"],"title":"Java位运算1_左移、右移","uri":"https://cens7.github.io/2016/02/java%E4%BD%8D%E8%BF%90%E7%AE%971_%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB/","year":"2016"},{"content":"广义表：  L=(a,b) L长度为2，深度为1\nL=(x,(a,b)）长度为2，深度为2\nL=(x,(a,b,c),y) 长度为3，深度为6\nL=(a,a,a,(a,\u0026hellip;))长度为4，深度为无穷大\n 无向图G5的邻接矩阵是： A1 ={0，1，1，1}\n{1，0，1，1}\n{1，1，0，0}\n{1，1，0，0}\n 有向图G6的邻接矩阵是：\n A2 = {0，1，0，0，0}\n{1，0，0，0，1}\n{0，1，0，1，0}\n{1，0，0，0，0}\n{0，0，0，1，0}\n  排序：内部排序：排序时不涉及数据的内、外存交换。适用于记录个数不很多的小文件。包括：插入排序、选择排序、交换排序、归并排序和分配排序。 外部排序：过程中要进行数据的内、外存交换。适用于记录个数太多，不能一次放到内存的大文件。     算法名 类别 平均 最好 最坏 辅助 稳定性     直接插入排序 插入排序 O(n²) O(n) O(n²) O(1) 稳定   希尔排序 插入排序 O(n^1.5) O(n) O(n²) O(1) 不稳定   简单选择排序 选择排序 O(n²) O(n²) O(n²) O(1) 不稳定   堆排序 选择排序 O(n㏒2n) O(n㏒2n) O(n㏒2n) O(1) 不稳定   冒泡排序 交换排序 O(n²) O(n) O(n²) O(1) 稳定   快速排序 交换排序 O(n㏒2n) O(n㏒2n) O(n²) O(n㏒2n) 不稳定   归并排序 归并排序 O(n㏒2n) O(n㏒2n) O(n㏒2n) O(1) 稳定   基数排序 基数排序 O(d(r+n)) O(d(rd+n)) O(d(r+n)) O(rd+n) 稳定     二叉树节点的度指父节点对应的下面孩子节点个数，最大为2。 BFS（Breadth-first Search）宽度优先搜索。先从根节点开始，搜索根节点左侧V1；搜索根节点右侧V2；搜索V1左侧V11；搜索V2右侧，当V2节点已经被V1搜索过，则V2停止。 DFS（Depth-first Search）深度优先搜索。先从根节点开始，搜索根节点左侧V1下面所有节点；搜索完再搜索根节点右侧V2所有节点。当V2节点已经被V1搜索过，则V2停止。 二路归并排序是把数组分成 n/2 +1个子数组，子数组内排序完成，在一直两两归并排序下去成一个数组。 图的广度优先遍历(BFS)类似于树的层次遍历。 图的深度优先遍历(DFS)类似于树的前序遍历。 直接插入排序后，可能未能选出一个元素放到其最终位置上。 快速排序、冒泡排序、希尔排序、堆排序原理。 二叉树等改路情况下平均查找长度等于= （∑(节点数量×节点个数)）÷所有节点个数。 堆排序是一种树形选择排序。 设线性表的长度为n，则顺序查找成功时的平均查找长度为 (n+1)/2。 抽象数据类型是指抽象数据的组织和与之相关的操作。 当三交矩阵的常数为0时，n阶三角矩阵的非零元素个数为n(n+1)/2。 有向图中的极大连通子图称作有向图的强连接分量。  ","id":10,"section":"posts","summary":"广义表： L=(a,b) L长度为2，深度为1 L=(x,(a,b)）长度为2，深度为2 L=(x,(a,b,c),y) 长度为3，深度为6 L=(a,a,a,(a,\u0026hellip;))长度为","tags":["数据结构"],"title":"数据结构学习笔记_1","uri":"https://cens7.github.io/2015/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/","year":"2015"}],"tags":[{"title":"docker","uri":"https://cens7.github.io/tags/docker/"},{"title":"Dubbo","uri":"https://cens7.github.io/tags/dubbo/"},{"title":"idea","uri":"https://cens7.github.io/tags/idea/"},{"title":"Java","uri":"https://cens7.github.io/tags/java/"},{"title":"lambda","uri":"https://cens7.github.io/tags/lambda/"},{"title":"redis","uri":"https://cens7.github.io/tags/redis/"},{"title":"SpringCloud","uri":"https://cens7.github.io/tags/springcloud/"},{"title":"xss","uri":"https://cens7.github.io/tags/xss/"},{"title":"安全","uri":"https://cens7.github.io/tags/%E5%AE%89%E5%85%A8/"},{"title":"工具","uri":"https://cens7.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"title":"数据结构","uri":"https://cens7.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"架构","uri":"https://cens7.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"title":"问题","uri":"https://cens7.github.io/tags/%E9%97%AE%E9%A2%98/"}]}